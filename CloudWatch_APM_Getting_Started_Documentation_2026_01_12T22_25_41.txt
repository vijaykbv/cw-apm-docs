Getting Started with CloudWatch APM

CloudWatch Application Performance Monitoring (APM) helps you understand, troubleshoot, and optimize your applications across distributed systems through Application Signals - our flagship observability platform. Whether you're a developer debugging code, an operator maintaining production systems, or an architect designing observability strategies, this guide will help you get started quickly.

Quick Navigation by Role

üë®‚Äçüíª Developers ‚Üí Jump to Instrument Your First Application  
üîß Operators ‚Üí Jump to Monitor Production Systems  
üèóÔ∏è Architects ‚Üí Jump to Design Your Observability Strategy

What is CloudWatch APM?

CloudWatch Application Performance Monitoring (APM) is AWS's comprehensive observability solution built on Application Signals - our flagship product that provides end-to-end visibility into your applications, from backend services to frontend user experiences.

Application Signals automatically discovers your application topology, instruments your code, and delivers three integrated monitoring capabilities that work together to give you complete observability:

The Three Pillars of Application Signals

üîç Application Performance Monitoring (APM)
Monitor backend services, APIs, and microservices

Track request flows across distributed systems with automatic instrumentation and distributed tracing. APM captures performance metrics, identifies bottlenecks, and maps service dependencies - all without manual configuration.

What you get:
‚Ä¢ Distributed traces showing request flows through your architecture
‚Ä¢ Service dependency maps with real-time health status
‚Ä¢ Performance metrics: latency (P50, P90, P99), throughput, error rates
‚Ä¢ Automatic service discovery for ECS, EKS, Lambda, and EC2

Example: Your checkout API is slow. APM traces reveal that a database query in the inventory service is taking 3 seconds, causing the entire checkout flow to lag.

üë§ Real User Monitoring (RUM)
Capture actual user experiences in production

Monitor how real users interact with your web applications across different browsers, devices, and geographies. RUM tracks page performance, JavaScript errors, and Core Web Vitals to help you understand and optimize the user experience.

What you get:
‚Ä¢ Page load times and navigation performance
‚Ä¢ JavaScript errors with stack traces
‚Ä¢ Core Web Vitals (LCP, FID, CLS) tracking
‚Ä¢ User session replays and journey analysis
‚Ä¢ Geographic and device-based performance insights

Example: Users in Europe report slow page loads. RUM data shows high latency for API calls to your US-East region, prompting you to deploy a CloudFront distribution.

ü§ñ Synthetic Monitoring
Proactively test critical flows before users do

Run automated tests 24/7 from multiple AWS regions to detect issues before they impact users. Synthetic canaries validate API functionality, monitor critical user journeys, and ensure your application meets SLAs.

What you get:
‚Ä¢ Scheduled API health checks (every 1-60 minutes)
‚Ä¢ Scripted browser tests for critical user flows
‚Ä¢ Multi-region availability monitoring
‚Ä¢ Baseline performance tracking
‚Ä¢ Proactive alerting before user impact

Example: A synthetic canary detects your login endpoint returning 500 errors at 3 AM, triggering an alert before your first users wake up and encounter the issue.

How They Work Together

The power of Application Signals comes from how these three capabilities complement each other to provide complete visibility:

Scenario: Complete Incident Investigation
Synthetics detects checkout flow failing ‚Üí Alert fires
APM traces show payment service throwing exceptions
RUM confirms real users experiencing the same failures
Resolution: APM trace reveals recent deployment introduced a bug

Time to resolution: 5 minutes instead of waiting for user complaints

Scenario: Performance Optimization
RUM identifies slow page loads on mobile (4.5s LCP)
APM traces show backend APIs are fast (200ms)
RUM reveals bottleneck is a 3MB hero image
Synthetics validates the fix after optimization

Result: Mobile LCP improves from 4.5s to 1.2s

The Unified View

Application Signals brings all three monitoring types together in a single service map:

Connected insights:
‚Ä¢ RUM ‚Üí APM: Click on a slow page load to see the backend trace that caused it
‚Ä¢ APM ‚Üí Synthetics: Compare real traffic performance to synthetic baselines
‚Ä¢ Synthetics ‚Üí RUM: Validate that synthetic tests match real user experiences
‚Ä¢ Single source of truth: All monitoring data correlated in one platform

Getting Started with Application Signals

You don't need to enable everything at once. Here's the recommended path:

Phase 1: Start with APM (Week 1)
‚Ä¢ Enable Application Signals for backend services
‚Ä¢ Get visibility into service dependencies
‚Ä¢ Establish performance baselines

Phase 2: Add Synthetics (Week 2-3)
‚Ä¢ Create canaries for critical user journeys
‚Ä¢ Set up proactive monitoring
‚Ä¢ Establish availability baselines

Phase 3: Enable RUM (Week 4+)
‚Ä¢ Add RUM to your web application
‚Ä¢ Track real user experiences
‚Ä¢ Correlate with backend performance

Key capabilities across Application Signals:
‚Ä¢ Automatic service discovery - No manual configuration needed
‚Ä¢ Distributed tracing - Follow requests from browser to backend and back
‚Ä¢ Real-time metrics - Latency, errors, and throughput across your entire stack
‚Ä¢ Service maps - Visualize dependencies, health status, and user impact
‚Ä¢ SLO tracking - Define and monitor service-level objectives with error budgets
‚Ä¢ Intelligent alerting - Get notified when user experience or service health degrades

Whether you're debugging a slow API endpoint, investigating a spike in client-side errors, or validating a deployment with synthetic tests, Application Signals provides the unified observability foundation you need.

Developers: Instrument Your First Application

What You'll Accomplish
In 15 minutes, you'll have Application Signals collecting APM traces and metrics from your backend services, with zero code changes for supported runtimes.

Prerequisites
‚Ä¢ Application running on AWS (ECS, EKS, EC2, or Lambda)
‚Ä¢ Supported runtime: Java, Python, .NET, Node.js, or Go
‚Ä¢ IAM permissions to enable Application Signals

Step 1: Choose Your Instrumentation Approach

Option A: Auto-Instrumentation (Recommended for Getting Started)
‚Ä¢ Zero code changes required
‚Ä¢ Works with Java, Python, .NET, Node.js
‚Ä¢ Automatic APM metric and trace collection
‚Ä¢ Best for: Quick starts, proof-of-concepts

Option B: OpenTelemetry Manual Instrumentation
‚Ä¢ Full control over what you instrument
‚Ä¢ Portable across observability platforms
‚Ä¢ Custom spans and attributes for APM, RUM, and Synthetics
‚Ä¢ Best for: Fine-grained control, custom metrics

Option C: AWS Distro for OpenTelemetry (ADOT)
‚Ä¢ AWS-optimized OpenTelemetry
‚Ä¢ Pre-configured for Application Signals
‚Ä¢ Best of both worlds
‚Ä¢ Best for: AWS-native apps wanting OTel flexibility

Step 2: Enable Application Signals

For Amazon EKS:

For Amazon ECS:
Add the Application Signals agent as a sidecar to your task definition:

For AWS Lambda:
Add the Lambda layer and environment variables:

Step 3: Verify APM Data Collection
Wait 5-10 minutes for data to appear
Open CloudWatch Console ‚Üí Application Signals
Check the Service Map - you should see your services with APM metrics
Click on a service to view distributed traces and performance metrics

Step 4: Add Custom Instrumentation (Optional)

Enhance your APM traces with custom spans and business context:

Python example:

Java example:

Step 5: Enable RUM for Frontend Monitoring (Optional)

Add the RUM web client to track user experiences:

Step 6: Create Synthetic Canaries (Optional)

Set up proactive monitoring with synthetic tests:

Troubleshooting for Developers

Not seeing APM traces?
‚Ä¢ Check IAM permissions include cloudwatch:PutMetricData and xray:PutTraceSegments
‚Ä¢ Verify the Application Signals agent is running: kubectl logs -n amazon-cloudwatch 
‚Ä¢ Ensure your application is generating traffic

RUM data not appearing?
‚Ä¢ Verify the RUM snippet is loaded before other scripts
‚Ä¢ Check browser console for errors
‚Ä¢ Confirm application ID and region are correct

Synthetic canaries failing?
‚Ä¢ Review canary logs in CloudWatch Logs
‚Ä¢ Test the script locally first
‚Ä¢ Verify network connectivity from canary VPC

High overhead from Application Signals?
‚Ä¢ Adjust APM trace sampling rate in agent configuration
‚Ä¢ Use head-based sampling for high-volume services
‚Ä¢ Consider sampling RUM sessions for high-traffic sites

Need help?
‚Ä¢ Sample applications on GitHub
‚Ä¢ Developer documentation

Operators: Monitor Production Systems

What You'll Accomplish
Set up comprehensive monitoring, alerting, and dashboards across APM, RUM, and Synthetics for your production applications in 30 minutes.

Your Monitoring Checklist

‚úÖ Service Health Monitoring (APM)
‚Ä¢ [ ] Service map shows all critical backend services
‚Ä¢ [ ] Key APM metrics dashboards created (latency, errors, throughput)
‚Ä¢ [ ] SLOs defined for critical services
‚Ä¢ [ ] Alerts configured for SLO violations

‚úÖ User Experience Monitoring (RUM)
‚Ä¢ [ ] RUM enabled on production web applications
‚Ä¢ [ ] Core Web Vitals tracking configured
‚Ä¢ [ ] Frontend error alerts set up
‚Ä¢ [ ] Geographic performance baselines established

‚úÖ Proactive Monitoring (Synthetics)
‚Ä¢ [ ] Canaries created for critical user journeys
‚Ä¢ [ ] API health checks running every 5 minutes
‚Ä¢ [ ] Multi-region availability monitoring enabled
‚Ä¢ [ ] Synthetic test failure alerts configured

‚úÖ Integrated Alerting
‚Ä¢ [ ] Alerts correlate APM, RUM, and Synthetics data
‚Ä¢ [ ] On-call runbooks linked to alerts
‚Ä¢ [ ] Error budget tracking enabled across all signals
‚Ä¢ [ ] Escalation policies defined

Step 1: Create Your Unified Dashboard

Pre-built Application Signals dashboard:
Navigate to CloudWatch ‚Üí Dashboards ‚Üí Create Dashboard
Select "Application Signals" template
Choose your services
Customize widgets to include:
‚Ä¢ APM Golden Signals: Backend latency, traffic, errors, saturation
‚Ä¢ RUM User Experience: Page load times, Core Web Vitals, JS errors
‚Ä¢ Synthetics Health: Canary pass rates, availability by region
‚Ä¢ Service Dependencies: Upstream/downstream health with RUM correlation

Key metrics to track across Application Signals:

APM Metrics:
‚Ä¢ Request rate (requests/second)
‚Ä¢ Error rate (%)
‚Ä¢ P50/P90/P99 latency (ms)
‚Ä¢ Dependency health

RUM Metrics:
‚Ä¢ Page load time (seconds)
‚Ä¢ Largest Contentful Paint (LCP)
‚Ä¢ First Input Delay (FID)
‚Ä¢ Cumulative Layout Shift (CLS)
‚Ä¢ JavaScript error rate

Synthetics Metrics:
‚Ä¢ Canary success rate (%)
‚Ä¢ Availability by region
‚Ä¢ Synthetic transaction duration
‚Ä¢ API response times

Step 2: Set Up Intelligent Alerts

SLO-based alerting across Application Signals:

Create composite alarms that span APM, RUM, and Synthetics:
Synthetic canary fails AND APM error rate high
RUM page load slow AND APM backend latency high
APM dependency failure AND RUM user impact detected

Alert routing best practices:
‚Ä¢ P1 (Critical): Synthetics down + APM errors + RUM impact ‚Üí Page on-call immediately
‚Ä¢ P2 (High): APM performance degradation + RUM slowness ‚Üí Slack notification + ticket
‚Ä¢ P3 (Medium): Isolated RUM errors or single canary failure ‚Üí Daily digest email

Step 3: Implement Runbook Automation

Link runbooks to Application Signals alerts:
‚Ä¢ Synthetic canary failure: Check APM service health ‚Üí Review recent deployments ‚Üí Rollback if needed
‚Ä¢ RUM performance degradation: Check APM backend latency ‚Üí Review CDN performance ‚Üí Optimize assets
‚Ä¢ APM service errors: Check RUM user impact ‚Üí Review traces ‚Üí Scale or restart services

Auto-remediation examples:
‚Ä¢ Restart unhealthy containers when APM detects failures
‚Ä¢ Scale up when APM shows high latency AND RUM shows user impact
‚Ä¢ Trigger circuit breakers when Synthetics detect downstream failures
‚Ä¢ Invalidate CDN cache when RUM shows stale content issues

Step 4: Establish Operational Reviews

Weekly Application Signals metrics review:
‚Ä¢ APM SLO compliance trends
‚Ä¢ RUM user experience trends (Core Web Vitals)
‚Ä¢ Synthetics availability and performance
‚Ä¢ Top errors across APM and RUM
‚Ä¢ Performance regressions detected by any signal
‚Ä¢ Capacity planning needs from APM metrics

Monthly deep dives:
‚Ä¢ Cost optimization across APM, RUM, and Synthetics
‚Ä¢ Alert fatigue analysis
‚Ä¢ Incident retrospectives using correlated data
‚Ä¢ Monitoring coverage gaps

Operational Excellence Tips

Reduce alert fatigue:
‚Ä¢ Use Application Signals' unified view to correlate before alerting
‚Ä¢ Implement alert suppression during deployments
‚Ä¢ Group related alerts across APM, RUM, and Synthetics
‚Ä¢ Regular alert tuning based on false positive rate

Optimize Application Signals costs:
‚Ä¢ Use APM trace sampling to reduce ingestion by 70-80%
‚Ä¢ Sample RUM sessions for high-traffic sites
‚Ä¢ Adjust Synthetics canary frequency based on criticality
‚Ä¢ Archive old traces to S3

Improve MTTR with Application Signals:
‚Ä¢ Pre-built investigation dashboards showing APM + RUM + Synthetics
‚Ä¢ Correlation between metrics, logs, and traces
‚Ä¢ Quick access to recent deployments
‚Ä¢ Jump from RUM error to APM trace in one click

Architects: Design Your Observability Strategy

What You'll Accomplish
Design a scalable, cost-effective Application Signals architecture that supports your organization's needs for the next 2-3 years.

Architecture Decision Framework

Decision 1: Application Signals Adoption Strategy

Full Stack vs. Phased Approach

| Approach | APM | RUM | Synthetics | Time to Value | Complexity |
|----------|-----|-----|------------|---------------|------------|
| Full Stack | ‚úÖ | ‚úÖ | ‚úÖ | 4-6 weeks | High |
| Backend First | ‚úÖ | ‚ùå | ‚ö†Ô∏è | 1-2 weeks | Low |
| Critical Path | ‚ö†Ô∏è | ‚ö†Ô∏è | ‚úÖ | 2-3 weeks | Medium |

Recommendation: Start with APM for backend visibility, add Synthetics for proactive monitoring, then enable RUM for user experience insights.

Decision 2: Instrumentation Strategy

OpenTelemetry vs. AWS Native for Application Signals

| Factor | OpenTelemetry | AWS Native |
|--------|---------------|------------|
| Portability | ‚úÖ Vendor-neutral | ‚ö†Ô∏è AWS-specific |
| Time to Value | ‚ö†Ô∏è More setup | ‚úÖ Faster |
| APM + RUM + Synthetics | ‚úÖ Full support | ‚úÖ Full support |
| Customization | ‚úÖ Full control | ‚ö†Ô∏è Limited |
| Support | Community | AWS Support |

Recommendation: Use OpenTelemetry for new applications to maintain flexibility, AWS native for rapid Application Signals adoption.

Decision 3: Multi-Cloud Strategy

Application Signals in Hybrid/Multi-Cloud:

Option A: Application Signals for AWS + Separate Tools
‚Ä¢ ‚úÖ Best-in-class for AWS workloads
‚Ä¢ ‚úÖ Full APM, RUM, and Synthetics integration
‚Ä¢ ‚ùå Multiple tools to manage
‚Ä¢ ‚ùå No unified view across clouds

Option B: OpenTelemetry + Unified Backend
‚Ä¢ ‚úÖ Single pane of glass
‚Ä¢ ‚úÖ Portable instrumentation
‚Ä¢ ‚ùå May lose Application Signals integration benefits
‚Ä¢ ‚ùå Higher complexity

Option C: Application Signals + OTel Collector Bridge
‚Ä¢ ‚úÖ AWS-optimized with flexibility
‚Ä¢ ‚úÖ Full APM, RUM, Synthetics on AWS
‚Ä¢ ‚úÖ Can forward to other backends
‚Ä¢ ‚ö†Ô∏è Additional infrastructure

Recommendation: Use Application Signals for AWS workloads, OTel for portability if multi-cloud is required.

Decision 4: Data Retention Strategy

APM Trace Data:
‚Ä¢ Hot storage: 7 days (fast queries)
‚Ä¢ Warm storage: 30 days (slower queries)
‚Ä¢ Cold storage: 90+ days (S3 archive)

RUM Session Data:
‚Ä¢ Hot storage: 30 days (active analysis)
‚Ä¢ Cold storage: 90+ days (compliance)

Synthetics Results:
‚Ä¢ Hot storage: 90 days (trend analysis)
‚Ä¢ Cold storage: 1+ years (SLA validation)

Metrics (APM, RUM, Synthetics):
‚Ä¢ High resolution (1 min): 15 days
‚Ä¢ Standard resolution (5 min): 63 days
‚Ä¢ Aggregated (1 hour): 15 months

Cost optimization: Use sampling and filtering across all Application Signals capabilities to reduce ingestion by 60-80% without losing visibility.

Reference Architecture Patterns

Pattern 1: Microservices on EKS with Full Application Signals

Key decisions:
‚Ä¢ ADOT collector as DaemonSet for centralized APM collection
‚Ä¢ RUM SDK embedded in frontend for user experience tracking
‚Ä¢ Synthetics canaries test critical paths from multiple regions
‚Ä¢ Service mesh (optional) for automatic APM instrumentation

Pattern 2: Serverless Applications with Application Signals

Key decisions:
‚Ä¢ Lambda layers for zero-code APM instrumentation
‚Ä¢ RUM tracks frontend to Lambda latency
‚Ä¢ Synthetics validates API Gateway endpoints
‚Ä¢ X-Ray integration for distributed APM tracing

Pattern 3: Hybrid Cloud with Application Signals

Key decisions:
‚Ä¢ OTel collector on-premises for APM data aggregation
‚Ä¢ Application Signals provides unified APM view
‚Ä¢ RUM enabled for AWS-hosted frontends
‚Ä¢ Synthetics tests both on-premises and AWS endpoints
‚Ä¢ Secure connectivity (VPN/Direct Connect)

Capacity Planning for Application Signals

Estimate your observability costs:

| Workload Size | APM Traces/Day | RUM Sessions/Day | Synthetics Runs/Day | Monthly Cost | Notes |
|---------------|----------------|------------------|---------------------|--------------|-------|
| Small (10 services) | 1M | 10K | 1,440 | $200-400 | Startup/dev |
| Medium (50 services) | 10M | 100K | 4,320 | $1,200-2,000 | Growing business |
| Large (200 services) | 100M | 1M | 14,400 | $8,000-15,000 | Enterprise |
| Very Large (1000+ services) | 1B+ | 10M+ | 43,200+ | $50,000+ | Hyperscale |

Cost optimization strategies across Application Signals:
‚Ä¢ Implement intelligent APM trace sampling (save 70-80%)
‚Ä¢ Sample RUM sessions for high-traffic sites (save 60-70%)
‚Ä¢ Adjust Synthetics canary frequency based on criticality (save 40-50%)
‚Ä¢ Use metric filters (save 40-60% on logs)
‚Ä¢ Archive cold data to S3 (save 90% on storage)
‚Ä¢ Right-size retention periods for each signal type

Security & Compliance

Data governance across Application Signals:
‚Ä¢ Encrypt APM traces, RUM data, and Synthetics results at rest and in transit
‚Ä¢ Implement data masking for PII in traces and RUM sessions
‚Ä¢ Use IAM for fine-grained access control
‚Ä¢ Enable CloudTrail for audit logging

Compliance considerations:
‚Ä¢ HIPAA: Enable encryption, audit trails, mask PHI in APM and RUM
‚Ä¢ PCI-DSS: Mask credit card data in APM traces and RUM sessions
‚Ä¢ GDPR: Implement data retention policies, support data deletion requests
‚Ä¢ SOC 2: Maintain access logs and reviews

Migration Planning to Application Signals

From X-Ray to Application Signals:

Phase 1: Parallel Run (2-4 weeks)
‚Ä¢ Enable Application Signals APM alongside X-Ray
‚Ä¢ Add RUM to frontend applications
‚Ä¢ Create initial Synthetics canaries
‚Ä¢ Compare data quality and coverage
‚Ä¢ Train teams on unified Application Signals UI

Phase 2: Gradual Migration (1-2 months)
‚Ä¢ Migrate non-critical services to Application Signals APM
‚Ä¢ Expand RUM coverage to all user-facing apps
‚Ä¢ Increase Synthetics coverage
‚Ä¢ Update dashboards to use Application Signals data
‚Ä¢ Validate SLO tracking across all signals

Phase 3: Full Cutover (1 month)
‚Ä¢ Migrate remaining services to Application Signals
‚Ä¢ Decommission X-Ray
‚Ä¢ Optimize costs with Application Signals features
‚Ä¢ Establish operational excellence practices

From Third-Party APM to Application Signals:
‚Ä¢ Assess current APM, RUM, and Synthetics instrumentation
‚Ä¢ Plan OTel migration if needed for portability
‚Ä¢ Consider dual-write during transition
‚Ä¢ Budget for 3-6 month migration
‚Ä¢ Leverage Application Signals' integrated approach for cost savings

Team Enablement

Training roadmap for Application Signals:
‚Ä¢ Week 1: Fundamentals workshop (APM, RUM, Synthetics overview)
‚Ä¢ Week 2-3: Hands-on labs (instrument services, enable RUM, create canaries)
‚Ä¢ Week 4: Production pilot with all three signals
‚Ä¢ Month 2+: Office hours and support

Center of Excellence:
‚Ä¢ Establish Application Signals champions
‚Ä¢ Create internal documentation for APM, RUM, and Synthetics best practices
‚Ä¢ Build reusable dashboards showing unified view
‚Ä¢ Share best practices for correlation and troubleshooting

Common Scenarios & Solutions

Scenario 1: Debugging a Slow API Endpoint

Developer approach:
Check RUM data - is the slowness visible to users?
Find the slow APM trace in Application Signals
Identify the bottleneck span in the trace
Add custom APM instrumentation for more detail
Deploy and verify improvement with RUM and Synthetics

Operator approach:
Check if Synthetics canaries are also slow (confirms issue)
Review APM traces to compare to baseline
Check RUM data for user impact
Look for correlated infrastructure issues
Escalate with APM trace evidence and RUM impact data

Scenario 2: Preparing for Black Friday

Architect approach:
Review APM capacity planning metrics
Establish SLOs across APM, RUM, and Synthetics
Set up proactive scaling policies based on APM metrics
Create war